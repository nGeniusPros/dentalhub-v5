{"version":3,"file":"RetellService.js","sourceRoot":"","sources":["../../../src/services/retell/RetellService.ts"],"names":[],"mappings":"AAAA,OAAO,SAAS,MAAM,IAAI,CAAC;AAQ3B,MAAM,OAAO,aAAa;IAIxB,YAAY,MAAoB;QAFxB,OAAE,GAAqB,IAAI,CAAC;QAGlC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAED,KAAK,CAAC,YAAY,CAChB,WAAmB,EACnB,MAAmB;QAEnB,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,OAAO,EAAE;YAC1D,MAAM,EAAE,MAAM;YACd,OAAO,EAAE;gBACP,cAAc,EAAE,kBAAkB;gBAClC,aAAa,EAAE,UAAU,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;aAC9C;YACD,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC;gBACnB,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO;gBAC7B,eAAe,EAAE,WAAW;gBAC5B,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK;gBACzB,GAAG,MAAM;aACV,CAAC;SACH,CAAC,CAAC;QAEH,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;YACjB,MAAM,IAAI,KAAK,CAAC,4BAA4B,QAAQ,CAAC,UAAU,EAAE,CAAC,CAAC;QACrE,CAAC;QAED,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC;IACzB,CAAC;IAED,gBAAgB,CACd,MAAc,EACd,QAIC;QAED,IAAI,CAAC;YACH,IAAI,CAAC,EAAE,GAAG,IAAI,SAAS,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,YAAY,MAAM,EAAE,CAAC,CAAC;YAElE,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE;gBACtB,OAAO,CAAC,GAAG,CAAC,4CAA4C,EAAE,MAAM,CAAC,CAAC;YACpE,CAAC,CAAC,CAAC;YAEH,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,IAAY,EAAE,EAAE;gBACrC,IAAI,CAAC;oBACH,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAqB,CAAC;oBAEnD,QAAQ,KAAK,CAAC,SAAS,EAAE,CAAC;wBACxB,KAAK,oBAAoB;4BACvB,QAAQ,CAAC,eAAe,EAAE,CAAC,KAA+D,CAAC,CAAC;4BAC5F,MAAM;wBACR,KAAK,YAAY;4BACf,QAAQ,CAAC,WAAW,EAAE,CAAC,KAAuD,CAAC,CAAC;4BAChF,IAAI,CAAC,UAAU,EAAE,CAAC;4BAClB,MAAM;oBACV,CAAC;gBACH,CAAC;gBAAC,OAAO,KAAK,EAAE,CAAC;oBACf,QAAQ,CAAC,OAAO,EAAE,CAAC,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBAChF,CAAC;YACH,CAAC,CAAC,CAAC;YAEH,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAK,EAAE,EAAE;gBAC5B,QAAQ,CAAC,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;YAC5B,CAAC,CAAC,CAAC;YAEH,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;gBACvB,OAAO,CAAC,GAAG,CAAC,uCAAuC,EAAE,MAAM,CAAC,CAAC;YAC/D,CAAC,CAAC,CAAC;QACL,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,QAAQ,CAAC,OAAO,EAAE,CAAC,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAChF,CAAC;IACH,CAAC;IAED,KAAK,CAAC,gBAAgB,CAAC,MAAc;QACnC,MAAM,QAAQ,GAAG,MAAM,KAAK,CAC1B,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,SAAS,MAAM,YAAY,EACjD;YACE,OAAO,EAAE;gBACP,aAAa,EAAE,UAAU,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;aAC9C;SACF,CACF,CAAC;QAEF,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;YACjB,MAAM,IAAI,KAAK,CAAC,iCAAiC,QAAQ,CAAC,UAAU,EAAE,CAAC,CAAC;QAC1E,CAAC;QAED,OAAO,QAAQ,CAAC,IAAI,EAAE,CAAC;IACzB,CAAC;IAED,KAAK,CAAC,gBAAgB,CAAC,MAAc,EAAE,MAAkB;QACvD,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,SAAS,MAAM,SAAS,EAAE;YAC3E,MAAM,EAAE,OAAO;YACf,OAAO,EAAE;gBACP,cAAc,EAAE,kBAAkB;gBAClC,aAAa,EAAE,UAAU,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;aAC9C;YACD,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;SAC7B,CAAC,CAAC;QAEH,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;YACjB,MAAM,IAAI,KAAK,CAAC,iCAAiC,QAAQ,CAAC,UAAU,EAAE,CAAC,CAAC;QAC1E,CAAC;IACH,CAAC;IAED,UAAU;QACR,IAAI,IAAI,CAAC,EAAE,EAAE,CAAC;YACZ,IAAI,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC;YAChB,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC;QACjB,CAAC;IACH,CAAC;CACF;AAED,MAAM,UAAU,mBAAmB,CAAC,MAAoB;IACtD,OAAO,IAAI,aAAa,CAAC,MAAM,CAAC,CAAC;AACnC,CAAC","sourcesContent":["import WebSocket from \"ws\";\nimport {\n  RetellConfig,\n  CallEventPayload,\n  CallResponse,\n  CallConfig,\n} from \"./types\";\n\nexport class RetellService {\n  private config: RetellConfig;\n  private ws: WebSocket | null = null;\n\n  constructor(config: RetellConfig) {\n    this.config = config;\n  }\n\n  async initiateCall(\n    phoneNumber: string,\n    config?: CallConfig,\n  ): Promise<CallResponse> {\n    const response = await fetch(`${this.config.baseUrl}/call`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${this.config.apiKey}`,\n      },\n      body: JSON.stringify({\n        agent_id: this.config.agentId,\n        customer_number: phoneNumber,\n        llm_id: this.config.llmId,\n        ...config,\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to initiate call: ${response.statusText}`);\n    }\n\n    return response.json();\n  }\n\n  connectWebSocket(\n    callId: string,\n    handlers: {\n      onTranscription?: (data: CallEventPayload & { eventType: \"call.transcription\" }) => void;\n      onCallEnded?: (data: CallEventPayload & { eventType: \"call.ended\" }) => void;\n      onError?: (error: Error) => void;\n    },\n  ): void {\n    try {\n      this.ws = new WebSocket(`${this.config.wsUrl}?call_id=${callId}`);\n\n      this.ws.on(\"open\", () => {\n        console.log(\"WebSocket connection established for call:\", callId);\n      });\n\n      this.ws.on(\"message\", (data: string) => {\n        try {\n          const event = JSON.parse(data) as CallEventPayload;\n\n          switch (event.eventType) {\n            case \"call.transcription\":\n              handlers.onTranscription?.(event as CallEventPayload & { eventType: \"call.transcription\" });\n              break;\n            case \"call.ended\":\n              handlers.onCallEnded?.(event as CallEventPayload & { eventType: \"call.ended\" });\n              this.disconnect();\n              break;\n          }\n        } catch (error) {\n          handlers.onError?.(error instanceof Error ? error : new Error(String(error)));\n        }\n      });\n\n      this.ws.on(\"error\", (error) => {\n        handlers.onError?.(error);\n      });\n\n      this.ws.on(\"close\", () => {\n        console.log(\"WebSocket connection closed for call:\", callId);\n      });\n    } catch (error) {\n      handlers.onError?.(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n\n  async getCallRecording(callId: string): Promise<Blob> {\n    const response = await fetch(\n      `${this.config.baseUrl}/call/${callId}/recording`,\n      {\n        headers: {\n          Authorization: `Bearer ${this.config.apiKey}`,\n        },\n      },\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to get call recording: ${response.statusText}`);\n    }\n\n    return response.blob();\n  }\n\n  async updateCallConfig(callId: string, config: CallConfig): Promise<void> {\n    const response = await fetch(`${this.config.baseUrl}/call/${callId}/config`, {\n      method: \"PATCH\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${this.config.apiKey}`,\n      },\n      body: JSON.stringify(config),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to update call config: ${response.statusText}`);\n    }\n  }\n\n  disconnect(): void {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n}\n\nexport function createRetellService(config: RetellConfig): RetellService {\n  return new RetellService(config);\n}\n"]}